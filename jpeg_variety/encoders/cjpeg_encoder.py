"""MozJPEG/libjpeg-turbo compatible `cjpeg` encoder plugin.

We focus on knobs that materially change the produced JPEG bitstream and the
visible artifact distribution:
- baseline vs progressive
- subsampling factors
- quantization table choice (predefined tables; rare custom tables)
- DCT method variants
- restart markers
- progressive scan optimization / trellis-related tuning

Implementation detail:
`cjpeg` does not natively consume PNG, so we convert PNG->PPM (P6) using Pillow
and stream it via stdin.

Option inventory source: cjpeg help output (provided with this project).
"""

from __future__ import annotations

import shutil
import tempfile
from dataclasses import dataclass
from pathlib import Path
from typing import Any

from PIL import Image

from ..utils.sampling import bernoulli, triangular_int, weighted_choice
from ..utils.subprocess import RunResult, run
from .base import EncodeContext, EncoderOptions, JPEGEncoder
from . import register_encoder
import os
import subprocess
from pathlib import Path
import logging

log = logging.getLogger(__name__)

# Classic JPEG Annex K example quantization tables (8x8, natural order).
# These are used only as a *seed* for rare custom-table generation.
ANNEXK_LUMA = [
    [16, 11, 10, 16, 24, 40, 51, 61],
    [12, 12, 14, 19, 26, 58, 60, 55],
    [14, 13, 16, 24, 40, 57, 69, 56],
    [14, 17, 22, 29, 51, 87, 80, 62],
    [18, 22, 37, 56, 68, 109, 103, 77],
    [24, 35, 55, 64, 81, 104, 113, 92],
    [49, 64, 78, 87, 103, 121, 120, 101],
    [72, 92, 95, 98, 112, 100, 103, 99],
]

ANNEXK_CHROMA = [
    [17, 18, 24, 47, 99, 99, 99, 99],
    [18, 21, 26, 66, 99, 99, 99, 99],
    [24, 26, 56, 99, 99, 99, 99, 99],
    [47, 66, 99, 99, 99, 99, 99, 99],
    [99, 99, 99, 99, 99, 99, 99, 99],
    [99, 99, 99, 99, 99, 99, 99, 99],
    [99, 99, 99, 99, 99, 99, 99, 99],
    [99, 99, 99, 99, 99, 99, 99, 99],
]


def _png_to_ppm_bytes(png_path: Path, *, background_rgb=(255, 255, 255)) -> bytes:
    """Load a PNG and produce binary PPM (P6) bytes."""

    with Image.open(png_path) as im:
        im.load()
        if im.mode in {"RGBA", "LA"} or (im.mode == "P" and "transparency" in im.info):
            # Composite alpha against background.
            bg = Image.new("RGBA", im.size, background_rgb + (255,))
            rgba = im.convert("RGBA")
            comp = Image.alpha_composite(bg, rgba).convert("RGB")
            im_rgb = comp
        else:
            im_rgb = im.convert("RGB")

        w, h = im_rgb.size
        header = f"P6\n{w} {h}\n255\n".encode("ascii")
        data = im_rgb.tobytes()
        return header + data


def _adjusted_progressive_prob(base_p: float, bucket: str) -> float:
    if bucket == "low":
        return max(0.05, base_p * 0.50)  # ~0.15
    if bucket == "high":
        return min(0.60, base_p * 1.33)  # ~0.40
    return base_p


def _adjusted_subsampling_weights(base: dict[str, float], bucket: str) -> dict[str, float]:
    if bucket == "low":
        return {"420": 0.88, "444": 0.08, "422": 0.04}
    if bucket == "high":
        return {"420": 0.68, "444": 0.27, "422": 0.05}
    return dict(base)


def _adjusted_quant_kind_weights(base: dict[str, float], bucket: str) -> dict[str, float]:
    # Modest nudge: high quality slightly increases perceptual/custom,
    # low quality increases Annex K / "standard" tables.
    b = dict(base)
    if bucket == "low":
        b["annex_k"] = b.get("annex_k", 0.0) + 0.08
        b["custom"] = max(0.01, b.get("custom", 0.0) - 0.02)
    elif bucket == "high":
        b["perceptual"] = b.get("perceptual", 0.0) + 0.06
        b["custom"] = b.get("custom", 0.0) + 0.01
        b["annex_k"] = max(0.10, b.get("annex_k", 0.0) - 0.05)
    return b


def _perturb_qtable(rng, table: list[list[int]], strength: float) -> list[list[int]]:
    """Perturb a base quant table by up to +/-strength fraction."""

    out: list[list[int]] = []
    for r, row in enumerate(table):
        out_row: list[int] = []
        for c, v in enumerate(row):
            # Slightly higher perturbation at higher frequencies.
            hf = (r + c) / 14.0
            local = strength * (0.35 + 0.65 * hf)
            delta = rng.uniform(-local, local)
            nv = int(round(v * (1.0 + delta)))
            out_row.append(max(1, min(255, nv)))
        out.append(out_row)
    return out


def _write_qtables_file(path: Path, luma: list[list[int]], chroma: list[list[int]]) -> None:
    lines: list[str] = []
    lines.append("# qtables generated by jpeg_variety (rare custom tables)")
    for row in luma:
        lines.append(" ".join(str(x) for x in row))
    lines.append("")
    for row in chroma:
        lines.append(" ".join(str(x) for x in row))
    path.write_text("\n".join(lines) + "\n", encoding="utf-8")

def _png_to_ppm_file(png_path: Path, ppm_path: Path, *, background_rgb=(255, 255, 255)) -> None:
    with Image.open(png_path) as im:
        im.load()
        if im.mode in {"RGBA", "LA"} or (im.mode == "P" and "transparency" in im.info):
            bg = Image.new("RGBA", im.size, background_rgb + (255,))
            rgba = im.convert("RGBA")
            comp = Image.alpha_composite(bg, rgba).convert("RGB")
            im_rgb = comp
        else:
            im_rgb = im.convert("RGB")

        w, h = im_rgb.size
        header = f"P6\n{w} {h}\n255\n".encode("ascii")
        data = im_rgb.tobytes()
        ppm_path.write_bytes(header + data)    


@register_encoder
class CjpegEncoder(JPEGEncoder):
    name = "cjpeg"
    default_weight = 0.75

    def __init__(self) -> None:
        self._exe = shutil.which("cjpeg")

    def is_available(self) -> bool:
        return self._exe is not None

    def sample_options(self, base_quality: int, rng, context: EncodeContext) -> EncoderOptions:
        bucket = context.quality_bucket
        sampling = context.sampling

        progressive = bernoulli(rng, _adjusted_progressive_prob(sampling.progressive_prob, bucket))
        subsampling = weighted_choice(rng, _adjusted_subsampling_weights(sampling.subsampling_weights, bucket))

        # DCT variants: int dominates, fast/float are legacy and rare.
        dct = weighted_choice(rng, {"int": 0.92, "fast": 0.05, "float": 0.03})

        # Quantization table selection.
        quant_kind = weighted_choice(rng, _adjusted_quant_kind_weights(sampling.quant_kind_weights, bucket))
        quant: dict[str, Any]

        # Map kind -> predefined table ids (0..8).
        if quant_kind == "annex_k":
            quant = {"kind": "predefined", "id": 0}
        elif quant_kind == "imagemagick":
            quant = {"kind": "predefined", "id": 3}
        elif quant_kind == "perceptual":
            # Prefer modern perceptual targets; keep other paper tables rare.
            qid = weighted_choice(rng, {2: 0.35, 4: 0.35, 5: 0.10, 6: 0.08, 7: 0.07, 8: 0.05})
            quant = {"kind": "predefined", "id": int(qid)}
        else:
            # Rare custom: perturb Annex K.
            strength = 0.20 if bucket == "high" else (0.12 if bucket == "mid" else 0.10)
            luma = _perturb_qtable(rng, ANNEXK_LUMA, strength)
            chroma = _perturb_qtable(rng, ANNEXK_CHROMA, strength)
            quant = {"kind": "custom", "generator": "perturbed_annexk", "strength": strength}

        # Progressive-related knobs.
        dc_scan_opt: int | None = None
        fastcrush = False
        if progressive:
            # dc-scan-opt: 1 is default. 0/2 less common.
            w = {1: 0.80, 2: 0.12, 0: 0.08}
            if bucket == "high":
                w = {1: 0.68, 2: 0.20, 0: 0.12}
            dc_scan_opt = int(weighted_choice(rng, w))
            fastcrush = bernoulli(rng, 0.08 if bucket == "low" else (0.12 if bucket == "mid" else 0.18))

        # Trellis toggles and tuning.
        trellis_disable_kind: str | None = None
        if bernoulli(rng, 0.04 if bucket == "low" else (0.02 if bucket == "mid" else 0.01)):
            trellis_disable_kind = weighted_choice(rng, {"notrellis": 0.40, "notrellis_dc": 0.60})

        tune_mode = None
        if trellis_disable_kind is None:
            tune_mode = weighted_choice(
                rng,
                {
                    "tune_hvs_psnr": 0.62,
                    "tune_psnr": 0.25,
                    "tune_ssim": 0.08,
                    "tune_ms_ssim": 0.05,
                },
            )

        # Restart markers: occasional, biased off.
        restart: dict[str, Any] | None = None
        restart_p = sampling.restart_prob
        if bucket == "low":
            restart_p = min(0.10, restart_p + 0.02)
        elif bucket == "high":
            restart_p = max(0.01, restart_p - 0.01)

        if bernoulli(rng, restart_p):
            use_blocks = bernoulli(rng, 0.20)
            if use_blocks:
                blocks = triangular_int(rng, 8, 128, 16)
                restart = {"unit": "blocks", "value": blocks}
            else:
                rows = triangular_int(rng, 1, 32, 4)
                restart = {"unit": "rows", "value": rows}

        # Baseline compatibility when custom tables or baseline mode.
        quant_baseline = False
        if not progressive and bernoulli(rng, 0.35):
            quant_baseline = True
        if quant.get("kind") == "custom" and bernoulli(rng, 0.70):
            quant_baseline = True

        normalized: dict[str, Any] = {
            "quality": int(base_quality),
            "progressive": bool(progressive),
            "subsampling": subsampling,
            "quant_table": quant,
            "dct": dct,
            "entropy": {"huffman_opt": True, "arithmetic": False},
            "restart": restart,
            "encoder_specific": {
                "dc_scan_opt": dc_scan_opt,
                "fastcrush": fastcrush,
                "trellis_disable": trellis_disable_kind,
                "tune": tune_mode,
                "quant_baseline": quant_baseline,
            },
        }

        # Store runtime details (avoid creating temp files here).
        internal: dict[str, Any] = {
            "progressive": progressive,
            "subsampling": subsampling,
            "dct": dct,
            "dc_scan_opt": dc_scan_opt,
            "fastcrush": fastcrush,
            "trellis_disable_kind": trellis_disable_kind,
            "tune_mode": tune_mode,
            "restart": restart,
            "quant": quant,
            "quant_baseline": quant_baseline,
            "cmd_template": ["cjpeg", "-quality", str(base_quality), "...", "-outfile", "<out.jpg>"]
        }

        # For custom quant, store concrete table matrices.
        if quant.get("kind") == "custom":
            strength = float(quant.get("strength", 0.12))
            internal["custom_tables"] = {
                "luma": _perturb_qtable(rng, ANNEXK_LUMA, strength),
                "chroma": _perturb_qtable(rng, ANNEXK_CHROMA, strength),
            }

        return EncoderOptions(normalized=normalized, internal=internal)

    def encode(self, input_png: Path, output_jpg: Path, options: EncoderOptions) -> RunResult:
        if self._exe is None:
            raise RuntimeError("cjpeg executable not found on PATH")

        
        #ppm_bytes = _png_to_ppm_bytes(input_png)
        with tempfile.NamedTemporaryFile(suffix=".ppm", delete=False) as f:
            ppm_path = Path(f.name)
        options.temp_paths.append(ppm_path)
        _png_to_ppm_file(input_png, ppm_path)        

        base_quality = int(options.normalized.get("quality", 75))

        cmd: list[str] = [self._exe, "-quality", str(base_quality)]

        progressive = bool(options.internal.get("progressive", False))
        if progressive:
            cmd.append("-progressive")
        else:
            cmd.append("-baseline")

        # Subsampling
        subsampling = str(options.internal.get("subsampling", "420"))
        sample_map = {
            "444": "1x1,1x1,1x1",
            "422": "2x1,1x1,1x1",
            "420": "2x2,1x1,1x1",
        }
        cmd.extend(["-sample", sample_map.get(subsampling, "2x2,1x1,1x1")])

        # DCT method
        dct = str(options.internal.get("dct", "int"))
        cmd.extend(["-dct", dct])

        # Quantization
        quant = options.internal.get("quant", {})
        if isinstance(quant, dict) and quant.get("kind") == "predefined":
            cmd.extend(["-quant-table", str(int(quant.get("id", 0)))])
        elif isinstance(quant, dict) and quant.get("kind") == "custom":
            tables = options.internal.get("custom_tables")
            if not isinstance(tables, dict) or "luma" not in tables or "chroma" not in tables:
                raise RuntimeError("custom quant selected but custom_tables missing")
            with tempfile.NamedTemporaryFile("w", suffix=".txt", delete=False, encoding="utf-8") as f:
                qpath = Path(f.name)
            _write_qtables_file(qpath, tables["luma"], tables["chroma"])
            options.temp_paths.append(qpath)
            cmd.extend(["-qtables", str(qpath), "-qslots", "0,1,1"])

        if bool(options.internal.get("quant_baseline", False)):
            cmd.append("-quant-baseline")

        # Progressive scan knobs
        dc_scan_opt = options.internal.get("dc_scan_opt")
        if progressive and dc_scan_opt is not None:
            cmd.extend(["-dc-scan-opt", str(int(dc_scan_opt))])

        if progressive and bool(options.internal.get("fastcrush", False)):
            cmd.append("-fastcrush")

        # Trellis tuning / disable
        tdk = options.internal.get("trellis_disable_kind")
        if tdk == "notrellis":
            cmd.append("-notrellis")
        elif tdk == "notrellis_dc":
            cmd.append("-notrellis-dc")
        else:
            tune_mode = options.internal.get("tune_mode")
            if tune_mode == "tune_psnr":
                cmd.append("-tune-psnr")
            elif tune_mode == "tune_ssim":
                cmd.append("-tune-ssim")
            elif tune_mode == "tune_ms_ssim":
                cmd.append("-tune-ms-ssim")
            else:
                # Default mozjpeg tuning is PSNR-HVS; specifying explicitly improves manifest clarity.
                cmd.append("-tune-hvs-psnr")

        # Restart markers
        restart = options.internal.get("restart")
        if isinstance(restart, dict) and restart.get("value") is not None:
            v = int(restart["value"])
            if restart.get("unit") == "blocks":
                cmd.extend(["-restart", f"{v}B"])
            else:
                cmd.extend(["-restart", str(v)])

        #cmd.extend([str(ppm_path)])
        output_jpg = Path(output_jpg).expanduser().resolve()
        cmd.extend(["-outfile", os.fspath(output_jpg), str(ppm_path)])
        
        
        #log.info("CMD: %s", cmd)
        #os.system("pause")
        # No inputfile argument => read stdin.
        #return run(cmd, input_bytes=ppm_bytes)
        return run(cmd)
